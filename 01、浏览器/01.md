### 1、Chrome 浏览器打开一个页面时，会启动哪些进程？

以 Chrome85 为例，在启动浏览器时会启动：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

![](./images/01.png)

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

相关阅读：
[现代浏览器内部揭秘](https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md)

[浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html)

### 垃圾回收算法

常见的垃圾回收算法有 `引用计数` 和 `标记-清除算法`;

#### 引用计数

`引用计数`是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

这种算法有一个缺陷：无法处理循环引用的事例。当两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

`引用计数`最大的好处是回收及时：一个对象的引用计数归零的那一刻即是它成为垃圾的那一刻，同时也是它被回收的那一刻。而这也是`标记-清除算法`的劣势：一个对象成为垃圾之后，直到被下一轮 GC 清理掉之前，还要在内存中留存一段时间（floating garbage）。

#### 标记-清除算法

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于`标记-清除算法`的改进。

#### V8 的垃圾回收算法做了哪些改进？

在 V8 中，将内存分为了新生代（new space）和老生代（old space）。它们特点如下：

- 新生代：对象的存活时间较短。这个区域很小，但垃圾回收非常频繁。
- 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

![](./images/02.png)

##### 新生代中使用的算法

新生代中的对象主要通过 `Scavenge` 算法进行垃圾回收。`Scavenge` 的具体实现，主要采用了 `Cheney` 算法。

`Cheney` 算法采用复制的方式进行垃圾回收。它将堆内存一分为二，每一部分空间称为 `semispace`。这两个空间，只有一个空间处于使用中，另一个则处于闲置。使用中的 `semispace` 称为 「From 空间」，闲置的 `semispace` 称为 「To 空间」。

过程如下：

1. 从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。
1. 检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间。
1. 若对象不存活，则释放不存活对象的空间。
1. 完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。

Scavenge 算法的缺点是，它的算法机制决定了只能利用一半的内存空间。但是新生代中的对象生存周期短、存活对象少，进行对象复制的成本不是很高，因而非常适合这种场景。

###### 对象晋升

对象晋升的条件有两个：

1. 对象是否经历过 `Scavenge` 回收。对象从 From 空间复制 To 空间时，会检查对象的内存地址来判断对象是否已经经过一次 `Scavenge` 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

1. To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，To 空间将翻转成 From 空间，继续进行对象内存的分配。若占比过大，将影响后续内存分配。

对象晋升到老生代后，将接受新的垃圾回收算法处理。

##### 老生代中使用的算法

老生代中的对象有两个特点，第一是存活对象多，第二个存活时间长。若在老生代中使用 Scavenge 算法进行垃圾回收，将会导致复制存活对象的效率不高，且还会浪费一半的空间。因而，V8 在老生代采用 `Mark-Sweep`（标记清除） 和 `Mark-Compact`（标记整理） 算法进行垃圾回收。

`Mark-Sweep` 主要分为标记和清除两个阶段：

- 标记阶段，它将遍历堆中所有对象，并对存活的对象进行标记；
- 清除阶段，对未标记对象的空间进行回收。

与 `Scavenge` 算法不同，`Mark-Sweep` 不会对内存一分为二，因此不会浪费空间。但是，经历过一次 `Mark-Sweep` 之后，内存的空间将会变得不连续，这样会对后续内存分配造成问题。

为了解决内存碎片的问题，提高对内存的利用，引入了 `Mark-Compact` 算法。`Mark-Compact` 是在 `Mark-Sweep` 算法上进行了改进，标记阶段与 `Mark-Sweep`相同，但是对未标记的对象处理方式不同。与`Mark-Sweep` 是对未标记的对象立即进行回收，`Mark-Compact` 则是将存活的对象移动到一边，然后再清理端边界外的内存。

由于 `Mark-Compact` 需要移动对象，所以执行速度上，比 `Mark-Sweep` 要慢。所以，V8 主要使用`Mark-Sweep` 算法，然后在当空间内存分配不足时，采用 `Mark-Compact` 算法。

###### Incremental Marking（增量标记）

如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并可能会让用户感觉到延迟。因此，V8 对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记

参考链接：
[MDN 内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)

[为什么 Python 要使用有明显缺陷的引用计数而不是像 JavaScript 一样的标记清除？](https://www.zhihu.com/question/33529443/answer/56755648)

[深入理解 V8 的垃圾回收原理](https://www.jianshu.com/p/b8ed21e8a4fb)

### 哪些操作会造成内存泄漏？

- 意外的全局变量
- 被遗忘的计时器或回调函数
- DOM 的引用
- 闭包

### JS 中数据如何存储？

### 1、排序算法

#### (1)、冒泡排序

```js
function bubbleSort(arr) {
  let len = arr.length - 1;
  for (let i = 0; i < len; i++) {
    // 声明一个变量，作为标志位；
    // 如果当前循环一次都没有交换位置，说明都排好序了，所以可以推出循环
    let done = true;
    for (let j = 0; j < len - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        done = false;
      }
    }
    if (done) {
      break;
    }
  }
  return arr;
}
```

#### (2)、快速排序

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr.splice(pivotIndex, 1)[0];
  const left = [];
  const right = [];

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  // 注意：这里返回的是一个新的数组
  return quickSort(left).concat(pivot, quickSort(right));
};
```

上面快排的实现虽然优雅，但是有大量创建数组的过程，导致性能不是很高。

下面是性能更高的写法：

```js
function swap(A, i, j) {
  [A[i], A[j]] = [A[j], A[i]]
}

function divide(A, p, r) {
  const x = A[r - 1];
  let i = p - 1;
  for (let j = p; j < r - 1; j++) {
    if (A[j] <= x) {
      i++;
      swap(A, i, j);
    }
  }
  swap(A, i + 1, r - 1);
  return i + 1;
}

function quickSort(A, p = 0, r) {
  r = r || A.length;
  if (p < r - 1) {
    const q = divide(A, p, r);
    quickSort(A, p, q);
    quickSort(A, q + 1, r);
  }
  return A;
}
```

(3)、归并排序

```js
function merge(leftArr, rightArr) {
  const result = [];
  while (leftArr.length > 0 && rightArr.length > 0) {
    if (leftArr[0] < rightArr[0]) {
      result.push(leftArr.shift());
    } else {
      result.push(rightArr.shift());
    }
  }
  // 可能 leftArr 或者 rightArr 中还有数据，所以这里做一下 concat
  return result.concat(leftArr).concat(rightArr);  
}

function mergeSort(array) {
  if (array.length == 1) {
    return array;
  }
  const middle = Math.floor(array.length / 2);       
  const left = array.slice(0, middle);               
  const right = array.slice(middle);
  // 注意：这里返回的是一个新的数组
  return merge(mergeSort(left), mergeSort(right));
}
```

### 2、洗牌算法

```js
function shuffle(a) {
  for (let i = a.length; i; i--) {
    let j = Math.floor(Math.random() * i);
    [a[i - 1], a[j]] = [a[j], a[i - 1]];
  }
  return a;
}
```

#### 补充

再看看下面的乱序写法会不会有问题：

```js
const values = [1, 2, 3, 4, 5];

values.sort(function(){
  return Math.random() - 0.5;
});

console.log(values)
```

上面的写法是有问题的，原因是浏览器JS引擎（以 v8 为例）在处理 sort 方法时，当目标数组长度小于 10 时，会使用插入排序；如果大于10，会使用快速排序和插入排序的混合排序。**在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底。**

参考阅读：

[JavaScript专题之乱序](https://github.com/mqyqingfeng/Blog/issues/51)
